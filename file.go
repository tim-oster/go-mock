package main

import (
	"fmt"
	"go/ast"
	"go/types"
	"log"
	"path"
	"strings"
	"unicode"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
)

const (
	testingPkg = "testing"
	mockPkg    = "github.com/stretchr/testify/mock"
)

var (
	mockReceiver = jen.Id("x")
)

type File struct {
	scope      *types.Scope
	pkgId      string
	pkgName    string
	filename   string
	interfaces []Interface
}

func parseFiles(pkg *packages.Package, targets map[string]string) []File {
	var files []File

	for i, file := range pkg.GoFiles {
		if strings.HasSuffix(file, "_mock.gen.go") {
			continue
		}
		f := File{
			scope:    pkg.Types.Scope(),
			filename: path.Join(pkg.Types.Path(), path.Base(file)),
			pkgId:    pkg.ID,
			pkgName:  pkg.Syntax[i].Name.Name,
		}
		ast.Inspect(pkg.Syntax[i], f.genDecl)
		if !f.filterInterfaces(targets) {
			continue
		}
		files = append(files, f)
	}

	return files
}

func (f *File) genDecl(node ast.Node) bool {
	spec, ok := node.(*ast.TypeSpec)
	if !ok {
		return true
	}
	obj := f.scope.Lookup(spec.Name.Name)
	if obj == nil {
		return true
	}
	typ, ok := obj.Type().(*types.Named)
	if !ok {
		return true
	}
	iface, ok := typ.Underlying().(*types.Interface)
	if !ok {
		return false
	}
	f.interfaces = append(f.interfaces, Interface{
		name: spec.Name.Name,
		spec: spec,
		typ:  iface,
	})
	return false
}

func (f *File) filterInterfaces(targets map[string]string) bool {
	var filtered []Interface

	for _, iface := range f.interfaces {
		rename, ok := targets[iface.name]
		if !ok {
			continue
		}
		if len(rename) > 0 {
			iface.name = rename
		}
		filtered = append(filtered, iface)
	}

	f.interfaces = filtered
	return len(f.interfaces) > 0
}

func (f *File) generate() {
	for _, iface := range f.interfaces {
		g := jen.NewFilePathName(f.pkgId, f.pkgName)
		g.PackageComment("Code generated by " + binaryName + ". DO NOT EDIT.")
		g.PackageComment("version: " + binaryName + " " + binaryVersion)
		g.PackageComment("source: " + f.filename)

		actualName := iface.spec.Name.Name
		generatedName := iface.name
		if actualName != generatedName {
			actualName += " (renamed to: " + generatedName + ")"
		}
		g.PackageComment("interface: " + actualName)

		g.PackageComment(fmt.Sprintf("flags: keepctx=%t unexported=%t", *keepCtx, *unexported))

		g.Line()

		iface.generate(g)

		filename := path.Base(f.filename)
		filename = strings.TrimSuffix(filename, ".go")
		filename += "_mock_" + strings.ToLower(iface.name)
		filename += ".gen.go"
		err := g.Save(filename)
		if err != nil {
			log.Fatal(err)
		}
	}
}

type Interface struct {
	name string
	spec *ast.TypeSpec
	typ  *types.Interface
}

func (iface *Interface) generate(g *jen.File) {
	mockName := "Mock"
	if *unexported {
		mockName = "mock"
	}
	if unicode.IsLower(rune(iface.name[0])) {
		mockName += "_"
	}
	mockName += iface.name

	// compile time interface implementation assert
	g.Var().Id("_").Id(iface.spec.Name.Name).Op("=").
		Params(jen.Op("*").Id(mockName)).Params(jen.Nil())

	// mock struct that implements mock.Mock
	g.Type().Id(mockName).StructFunc(func(g *jen.Group) {
		g.Qual(mockPkg, "Mock")
	})

	for i := 0; i < iface.typ.NumMethods(); i++ {
		m := iface.typ.Method(i)
		iface.generateForMethod(g, mockName, m)
	}
}

func (iface *Interface) generateForMethod(g *jen.File, structName string, fn *types.Func) {
	sig := fn.Type().(*types.Signature)

	mockedInput := tupleToJen(sig.Params(), sig.Variadic())
	for i, p := range mockedInput {
		if i == 0 && p.Name == "ctx" && !*keepCtx {
			mockedInput = append(mockedInput[:i], mockedInput[i+1:]...)
		}
	}
	m := Method{
		structName:  structName,
		name:        fn.Name(),
		params:      tupleToJen(sig.Params(), sig.Variadic()),
		results:     tupleToJen(sig.Results(), false),
		mockedInput: mockedInput,
	}

	m.generateMockImplementation(g)
	g.Line()
	m.generateCallStruct(g)
	g.Line()
	m.generateOnMethods(g)
	g.Line()
	m.generateAssertMethods(g)
	g.Line()
}

type Method struct {
	structName  string
	name        string
	params      Params
	results     Params
	mockedInput Params
}

func (m *Method) generateMockImplementation(g *jen.File) {
	g.Func().
		Params(jen.Add(mockReceiver).Op("*").Id(m.structName)).
		Id(m.name).
		Params(m.params.ToSignatureParams(RenamePostfix)...).
		Params(m.results.ToSignatureParams(nil)...).
		BlockFunc(func(g *jen.Group) {
			g.Id("args").Op(":=").Add(mockReceiver).Dot("Called").Call(m.mockedInput.ToCallParams(RenamePostfix)...)

			g.If(jen.Len(jen.Id("args")).Op(">").Lit(0)).BlockFunc(func(g *jen.Group) {
				g.If(
					jen.List(jen.Id("t"), jen.Id("ok")).Op(":=").
						Id("args").Dot("Get").Call(jen.Lit(0)).Op(".").Params(jen.Id(m.returnFuncName())),
					jen.Id("ok"),
				).BlockFunc(func(g *jen.Group) {
					invocation := jen.Id("t").Params(m.params.ToCallParams(RenamePostfix)...)
					if len(m.results) > 0 {
						g.Return(invocation)
					} else {
						g.Add(invocation)
					}
				})
			})

			if len(m.results) > 0 {
				returnIds := make([]jen.Code, 0, len(m.results))
				for i, result := range m.results {
					id := jen.Id(fmt.Sprintf("r%d", i))
					returnIds = append(returnIds, id)

					g.Var().Add(id).Add(result.Type)
					g.If(
						jen.Id("v").Op(":=").Id("args").Dot("Get").Call(jen.Lit(i)),
						jen.Id("v").Op("!=").Nil(),
					).BlockFunc(func(g *jen.Group) {
						g.Add(id).Op("=").Id("v").Op(".").Params(result.Type)
					})
				}
				g.Return(returnIds...)
			}
		})
}

func (m *Method) callStructName() string {
	structName := []byte(m.structName)
	structName[0] = byte(unicode.ToLower(rune(structName[0])))
	return string(structName) + "_" + m.name
}

func (m *Method) returnFuncName() string {
	return m.callStructName() + "_ReturnFunc"
}

func (m *Method) generateCallStruct(g *jen.File) {
	mockCallStruct := m.callStructName()

	// actual call struct
	g.Type().Id(mockCallStruct).Struct(
		jen.Op("*").Qual(mockPkg, "Call"),
	).Line()

	// generate return function type for mocking custom logic
	g.Type().Id(m.returnFuncName()).Func().Params(m.params.ToSignatureParams(nil)...).
		Params(m.results.ToSignatureParams(nil)...).
		Line()

	// mockStruct.Return
	g.Func().
		Params(jen.Id("c").Op("*").Id(mockCallStruct)).
		Id("Return").
		Params(m.results.ToSignatureParams(RenameUnnamed)...).
		Params(jen.Op("*").Qual(mockPkg, "Call")).
		BlockFunc(func(g *jen.Group) {
			g.Id("values").Op(":=").Id("make").Call(
				jen.Index().Interface(),
				jen.Lit(len(m.results)),
			)
			for i, param := range m.results {
				RenameUnnamed.rename(i, &param)
				assignment := jen.Id("values").Index(jen.Lit(i)).Op("=").Id(param.Name)
				if !isNillable(param.AstType) {
					g.Add(assignment)
				} else {
					g.If(jen.Id(param.Name).Op("!=").Nil()).Block(assignment)
				}
			}
			g.Return(jen.Id("c").Dot("Call").Dot("Return").Call(
				jen.Id("values").Op("..."),
			))
		}).
		Line()

	// mockStruct.ReturnFn
	g.Func().
		Params(jen.Id("c").Op("*").Id(mockCallStruct)).
		Id("ReturnFn").
		Params(jen.Id("fn").Id(m.returnFuncName())).
		Params(jen.Op("*").Qual(mockPkg, "Call")).
		BlockFunc(func(g *jen.Group) {
			g.Return(jen.Id("c").Dot("Call").Dot("Return").Call(jen.Id("fn")))
		}).
		Line()
}

func (m *Method) generateOnMethods(g *jen.File) {
	genFunc := func(name string, sigParams []jen.Code, callParams []jen.Code) {
		callParams = append([]jen.Code{jen.Lit(m.name)}, callParams...)

		g.Func().
			Params(jen.Add(mockReceiver).Op("*").Id(m.structName)).
			Id(name).
			Params(sigParams...).
			Params(jen.Op("*").Id(m.callStructName())).
			BlockFunc(func(g *jen.Group) {
				g.Return(jen.Op("&").Id(m.callStructName()).Values(jen.Dict{
					jen.Id("Call"): jen.Add(mockReceiver).Dot("On").Call(callParams...),
				}))
			}).
			Line()
	}

	// mockStruct.On_xxx
	genFunc(
		"On_"+m.name,
		m.mockedInput.ToSignatureParams(RenamePostfix),
		m.mockedInput.ToCallParams(RenamePostfix),
	)

	// mockStruct.On_xxx_Any
	if len(m.mockedInput) > 0 {
		var anythings []jen.Code
		for range m.mockedInput {
			anythings = append(anythings, jen.Qual(mockPkg, "Anything"))
		}
		genFunc("On_"+m.name+"_Any", nil, anythings)
	}

	// mockStruct.On_xxx_Interface
	var interfacedParams Params
	for _, param := range m.mockedInput {
		param.Type = jen.Interface()
		interfacedParams = append(interfacedParams, param)
	}
	if len(interfacedParams) > 0 {
		genFunc(
			"On_"+m.name+"_Interface",
			interfacedParams.ToSignatureParams(RenamePostfix),
			interfacedParams.ToCallParams(RenamePostfix),
		)
	}
}

func (m *Method) generateAssertMethods(g *jen.File) {
	genFunc := func(name, implName string, sigParams []jen.Code, callParams []jen.Code) {
		sigParams = append([]jen.Code{jen.Id("t").Op("*").Qual(testingPkg, "T")}, sigParams...)
		callParams = append([]jen.Code{jen.Id("t"), jen.Lit(m.name)}, callParams...)

		g.Func().
			Params(jen.Add(mockReceiver).Op("*").Id(m.structName)).
			Id(name).
			Params(sigParams...).
			Params(jen.Bool()).
			BlockFunc(func(g *jen.Group) {
				g.Return(jen.Add(mockReceiver).Dot(implName).Params(callParams...))
			}).
			Line()
	}

	// Assert_xxx_Called function
	genFunc(
		"Assert_"+m.name+"_Called",
		"AssertCalled",
		m.mockedInput.ToSignatureParams(RenamePostfix),
		m.mockedInput.ToCallParams(RenamePostfix),
	)

	// Assert_xxx_NumberOfCalls function
	genFunc(
		"Assert_"+m.name+"_NumberOfCalls",
		"AssertNumberOfCalls",
		[]jen.Code{jen.Id("expectedCalls").Int()},
		[]jen.Code{jen.Id("expectedCalls")},
	)

	// Assert_xxx_NotCalled function
	genFunc(
		"Assert_"+m.name+"_NotCalled",
		"AssertNotCalled",
		m.mockedInput.ToSignatureParams(RenamePostfix),
		m.mockedInput.ToCallParams(RenamePostfix),
	)
}
